--- START TEXT FILE path: "native.ini" size: 146 b blake3: 207e0a027c3b06104c00458c6afdebf3645b5a6f0326ae598acb2f3353c70f80 ---
[host_machine]
system = 'darwin'
cpu_family = 'x86_64'
cpu = 'x86_64'
endian = 'little'

[binaries]
c = '/usr/bin/clang'
cpp = '/usr/bin/clang++'

--- END_OF_FILE ---
--- START TEXT FILE path: "gitpack.sh" size: 1276 b blake3: d7287b22da186fbd67ae37f853c366983caeee6d9ec5bf3e0a988bc12bae5c04 ---
#!/bin/bash

# Usage check
if [ "$#" -ne 1 ]; then
    echo "Error: Invalid number of arguments." >&2
    echo "Usage: $0 <path_to_git_directory>" >&2
    exit 1
fi

source_dir="$1"

# Validate path
if [ ! -d "$source_dir" ]; then
    echo "Error: Source directory '$source_dir' does not exist." >&2
    exit 1
fi

if [ ! -d "$source_dir/.git" ]; then
    echo "Error: Directory '$source_dir' does not appear to be a Git repository (no .git directory)." >&2
    exit 1
fi

# Determine portable base64 command
if base64 --version 2>/dev/null | grep -qi 'gnu'; then
    base64_cmd() { base64 "$1"; }
else
    base64_cmd() { base64 -i "$1"; }  # BSD/macOS variant
fi

# Binary file detection (true if non-text)
is_binary() {
    local file_path="$1"
    LC_ALL=C grep -qI . "$file_path"
    return $((! $?))  # invert result: true = binary
}

# Main loop
git -C "$source_dir" ls-files -c --others --exclude-standard | while IFS= read -r file; do
    full_path="${source_dir}/${file}"

    echo " -> Processing: $file" >&2
    echo "--- START FILE: ${file} ---"

    if is_binary "$full_path"; then
        echo "[base64]"
        base64_cmd "$full_path"
    else
        cat "$full_path"
    fi

    echo
    echo "--- END FILE: ${file} ---"
    echo
done

echo "Finished." >&2


--- END_OF_FILE ---
--- START TEXT FILE path: "README.md" size: 5686 b blake3: cbaaee12076ddeb3661ac82c170496a4d926725c2e4041d6f5bbb2e819e0c9db ---
# dirpacker

> **dirpacker** ‚Äì Lightweight, text-based directory archiver for code sharing and AI prompting.

`dirpacker` is a minimal, dependency-focused tool that serializes an entire directory into a single, human-readable text stream. It's ideal for:
- Sharing project structure with AI assistants (e.g. LLMs)
- Archiving codebases without binary formats
- Debugging or auditing file inclusions/exclusions
- Secure, transparent packaging (no compression, no hidden data)

All files are wrapped in clear markers, and binary files are Base64-encoded. Rules from `.dpignore` (like `.gitignore`) control what's included.

![Example output snippet](https://via.placeholder.com/600x200?text=---+START+TEXT+FILE+main.cpp+---\n#include+<iostream>\n...\n---+END_OF_FILE+---)
*Example of serialized output*



## ‚ú® Features

- ‚úÖ **Text-only output** ‚Äì safe for AI, logs, diffs
- ‚úÖ **Binary file support** via Base64 encoding
- ‚úÖ **`.dpignore` support** ‚Äì ignore files/dirs like `.gitignore`
- ‚úÖ **Filter by type**: `--text-only` skips binaries
- ‚úÖ **Limit by size**: `-l 100k` skips large files
- ‚úÖ **Dry-run & stats**: preview what would be packed
- ‚úÖ **No compression** ‚Äì fully inspectable output
- ‚úÖ **Cross-platform**: Linux, macOS, Windows (MSVC/MinGW)



## üõ†Ô∏è Build Instructions

`dirpacker` uses **Meson + Ninja** ‚Äì fast, modern, and portable.

### Prerequisites

- **C++17 compiler** (GCC 8+, Clang 7+, MSVC 19.14+)
- **Meson** (v0.55+)
- **Ninja** (bundled with Meson on most systems)
- **Git** (to clone)

Install Meson:
```bash
# Linux/macOS (pip)
pip3 install meson ninja

# Ubuntu/Debian
sudo apt install meson ninja-build

# Fedora
sudo dnf install meson ninja-build

# macOS (Homebrew)
brew install meson ninja

# Windows (MSYS2)
pacman -S meson mingw-w64-x86_64-ninja
```



### üêß Linux & üçè macOS

```bash
# Clone the repo
git clone https://github.com/mkopa/dp.git
cd dp

# Configure build
meson setup build

# Compile
meson compile -C build

# Run
./build/dirpacker --help
```



### üíª Windows

#### Option 1: MSYS2 / MinGW-w64 (Recommended)

```bash
# Install MSYS2 from https://www.msys2.org/
# Open "MSYS2 MinGW 64-bit"

# Update and install
pacman -Syu
pacman -S git mingw-w64-x86_64-gcc mingw-w64-x86_64-meson mingw-w64-x86_64-ninja

# Clone and build
git clone https://github.com/mkopa/dp.git
cd dp
meson setup build
meson compile -C build

# Run
./build/dirpacker.exe --help
```

#### Option 2: Visual Studio (MSVC)

Ensure you have **Visual Studio 2019+** with C++ tools.

```bash
# Open x64 Native Tools Command Prompt
git clone https://github.com/mkopa/dp.git
cd dp

# Meson will auto-detect MSVC
meson setup build
meson compile -C build

dirpacker.exe --help
```



## üß∞ Usage

```bash
dirpacker -d <DIRECTORY> [OPTIONS]
```

### Required
- `-d, --dir DIR` ‚Äì input directory to pack

### Optional
- `-o, --out FILE` ‚Äì output file (default: stdout)
- `-t, --text-only` ‚Äì skip binary files
- `-l, --limit SIZE` ‚Äì skip files larger than SIZE (e.g. `100k`, `1m`, `512b`)
- `--dry-run` ‚Äì simulate without writing
- `--stats` ‚Äì show summary after completion
- `-v, --version` ‚Äì show version
- `-h, --help` ‚Äì show help



### Examples

```bash
# Pack current dir to stdout
dirpacker -d .

# Save to file
dirpacker -d . -o project.pack

# Pipe to another tool
dirpacker -d src -l 100k | wc -c

# Dry run with stats
dirpacker -d . --dry-run --stats

# Only text files, max 50KB
dirpacker -d . -t -l 50k -o code_text.pack
```



## üìÅ `.dpignore`

Place a `.dpignore` file in your input directory to exclude files. Syntax is `.gitignore`-like:

```gitignore
# Comments
*.log
*.tmp
build/
dist/
node_modules/
*.exe
*.dll

# Exceptions
!important.txt
!docs/README.md
```

Rules are matched recursively. Paths are normalized to forward slashes (`/`).

> üí° Tip: Use `--dry-run --stats` to verify what will be included.



## üì¶ Output Format

Each file is wrapped like this:

```
--- START TEXT FILE path/to/file.txt 1234 ---
(file content here)
--- END_OF_FILE ---
```

or for binaries:

```
--- START BINARY FILE image.png 5678 ---
(base64-encoded data)
--- END_OF_FILE ---
```

This makes parsing and debugging trivial.



## üìÑ License

MIT License ‚Äì see [LICENSE](LICENSE) for details.

> Copyright ¬© 2025 Marcin

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files, to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



## üôå Contributing

PRs welcome! Please ensure:
- Code compiles on all platforms
- No new dependencies
- Follows existing style
- Updates README if needed



## üêû Bug Reports

Open an issue with:
- OS and compiler
- `meson --version`
- Exact command
- Expected vs actual output



> üè∑Ô∏è `dirpacker` ‚Äì because sometimes you just need to send the code, not the noise.
--- END_OF_FILE ---
--- START TEXT FILE path: "src/main.cpp" size: 22761 b blake3: 5ce142d709f942f7b3d04153c10b39aa17ad0ff8ff273630fdd05c2a10825f32 ---
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <filesystem>
#include <stdexcept>
#include <algorithm>
#include <sstream>
#include <regex>
#include <iomanip>
#include <map>
#include <system_error> // Potrzebne do przechwytywania b≈Çƒôd√≥w systemowych

// Zale≈ºno≈õci projektu
#include "blake3/blake3.h"
#include <cppcodec/base64_rfc4648.hpp>

// Zintegrowana biblioteka dla SHA
#include "sha256.h"
#include "sha3.h"

namespace fs = std::filesystem;

const std::string END_OF_RECORD = "\n--- END_OF_FILE ---\n";
constexpr const char *VERSION = "1.2.1"; // Podniesienie wersji (bugfix/robustness)

enum class HashAlgorithm
{
    BLAKE3,
    SHA256,
    SHA3_256
};

// --- Funkcje pomocnicze ---

std::string to_string(HashAlgorithm algo)
{
    static const std::map<HashAlgorithm, std::string> lookup = {
        {HashAlgorithm::BLAKE3, "blake3"},
        {HashAlgorithm::SHA256, "sha256"},
        {HashAlgorithm::SHA3_256, "sha3-256"}};
    return lookup.at(algo);
}

std::string bytes_to_hex(const uint8_t *bytes, size_t len)
{
    std::stringstream ss;
    ss << std::hex << std::setfill('0');
    for (size_t i = 0; i < len; ++i)
    {
        ss << std::setw(2) << static_cast<int>(bytes[i]);
    }
    return ss.str();
}

// NOWA funkcja: haszowanie danych z pamiƒôci (dla komunikat√≥w o b≈Çƒôdach)
std::string compute_hash_from_memory(const std::string &data, HashAlgorithm algo)
{
    const char *data_ptr = data.c_str();
    size_t data_len = data.length();

    switch (algo)
    {
    case HashAlgorithm::BLAKE3:
    {
        uint8_t hash[BLAKE3_OUT_LEN];
        blake3_hasher hasher;
        blake3_hasher_init(&hasher);
        blake3_hasher_update(&hasher, data_ptr, data_len);
        blake3_hasher_finalize(&hasher, hash, BLAKE3_OUT_LEN);
        return bytes_to_hex(hash, BLAKE3_OUT_LEN);
    }
    case HashAlgorithm::SHA256:
    {
        SHA256 sha256;
        sha256.add(data_ptr, data_len);
        return sha256.getHash();
    }
    case HashAlgorithm::SHA3_256:
    {
        SHA3 sha3(SHA3::Bits256);
        sha3.add(data_ptr, data_len);
        return sha3.getHash();
    }
    default:
        throw std::runtime_error("Unknown or unsupported hash algorithm.");
    }
}

std::string compute_hash(const fs::path &path, HashAlgorithm algo)
{
    std::ifstream file(path, std::ios::binary);
    if (!file)
    {
        throw std::runtime_error("Cannot open file for hashing: " + path.string());
    }
    std::vector<char> buffer(8192);

    switch (algo)
    {
    case HashAlgorithm::BLAKE3:
    {
        blake3_hasher hasher;
        blake3_hasher_init(&hasher);
        while (file.read(buffer.data(), buffer.size()) || file.gcount() > 0)
        {
            blake3_hasher_update(&hasher, reinterpret_cast<const uint8_t *>(buffer.data()), file.gcount());
        }
        uint8_t hash[BLAKE3_OUT_LEN];
        blake3_hasher_finalize(&hasher, hash, BLAKE3_OUT_LEN);
        return bytes_to_hex(hash, BLAKE3_OUT_LEN);
    }
    case HashAlgorithm::SHA256:
    {
        SHA256 sha256;
        while (file.read(buffer.data(), buffer.size()) || file.gcount() > 0)
        {
            sha256.add(buffer.data(), file.gcount());
        }
        return sha256.getHash();
    }
    case HashAlgorithm::SHA3_256:
    {
        SHA3 sha3(SHA3::Bits256);
        while (file.read(buffer.data(), buffer.size()) || file.gcount() > 0)
        {
            sha3.add(buffer.data(), file.gcount());
        }
        return sha3.getHash();
    }
    default:
        throw std::runtime_error("Unknown or unsupported hash algorithm.");
    }
}

// ... (reszta funkcji pomocniczych, kt√≥re siƒô nie zmieniajƒÖ)
std::string to_forward_slash(const fs::path &p) { return p.generic_string(); }
uintmax_t parse_size(const std::string &size_str)
{
    std::regex re(R"((\d+)([bkmg]?)?)", std::regex_constants::icase);
    std::smatch match;
    if (std::regex_match(size_str, match, re))
    {
        uintmax_t value = std::stoull(match[1].str());
        if (match[2].matched)
        {
            char unit = std::tolower(match[2].str()[0]);
            if (unit == 'k')
                value *= 1024;
            else if (unit == 'm')
                value *= 1024 * 1024;
            else if (unit == 'g')
                value *= 1024 * 1024 * 1024;
        }
        return value;
    }
    throw std::invalid_argument("Invalid size format: " + size_str);
}
bool is_binary(const fs::path &file_path)
{
    constexpr size_t check_size = 8000;
    std::ifstream file(file_path, std::ios::binary);
    if (!file)
    {
        throw std::runtime_error("Cannot open file: " + file_path.string());
    }
    std::vector<char> buffer(check_size);
    file.read(buffer.data(), buffer.size());
    std::streamsize bytes_read = file.gcount();
    return std::find(buffer.begin(), buffer.begin() + bytes_read, '\0') != buffer.begin() + bytes_read;
}
struct IgnoreRule
{
    std::regex regex;
    bool is_negated;
};
std::vector<IgnoreRule> load_dpignore_rules(const fs::path &base_dir, bool verbose)
{
    std::vector<IgnoreRule> rules;
    fs::path ignore_file = base_dir / ".dpignore";
    if (verbose)
        std::cerr << "üîç Looking for .dpignore in: " << base_dir << std::endl;
    if (fs::exists(ignore_file) && fs::is_regular_file(ignore_file))
    {
        if (verbose)
            std::cerr << "‚úÖ .dpignore found and opened." << std::endl;
        std::ifstream file(ignore_file);
        if (!file.is_open())
        {
            std::cerr << "Warning: Could not read .dpignore in " << base_dir << std::endl;
            return rules;
        }
        std::string line;
        while (std::getline(file, line))
        {
            line.erase(0, line.find_first_not_of(" \t\r\n"));
            line.erase(line.find_last_not_of(" \t\r\n") + 1);
            if (line.empty() || line[0] == '#')
                continue;
            bool is_negated = false;
            if (line[0] == '!')
            {
                is_negated = true;
                line = line.substr(1);
            }
            if (line.empty())
                continue;
            std::string regex_pattern;
            for (char c : line)
            {
                if (c == '*')
                    regex_pattern += ".*";
                else if (c == '?')
                    regex_pattern += ".";
                else if (std::string(".+()[]{}|^$\\").find(c) != std::string::npos)
                    regex_pattern += std::string("\\") + c;
                else
                    regex_pattern += c;
            }
            try
            {
                IgnoreRule rule = {std::regex(regex_pattern, std::regex_constants::icase), is_negated};
                rules.push_back(rule);
                if (verbose)
                    std::cerr << "üìã Loaded rule: " << (is_negated ? "EXCEPT " : "IGNORE ") << regex_pattern << std::endl;
            }
            catch (const std::regex_error &e)
            {
                std::cerr << "Warning: Invalid regex in .dpignore: " << line << " -> " << regex_pattern << " (" << e.what() << ")" << std::endl;
            }
        }
    }
    else
    {
        if (verbose)
            std::cerr << "‚ùå .dpignore NOT found in: " << base_dir << std::endl;
    }
    return rules;
}
bool should_ignore(const fs::path &path, const std::vector<IgnoreRule> &rules, bool verbose)
{
    std::string path_str = to_forward_slash(path);
    bool is_ignored = false;
    for (const auto &rule : rules)
    {
        if (std::regex_search(path_str, rule.regex))
        {
            is_ignored = !rule.is_negated;
        }
    }
    if (is_ignored && verbose)
    {
        std::cerr << "üö´ Ignored by rule: " << path_str << std::endl;
    }
    return is_ignored;
}

struct Stats
{
    uintmax_t processed = 0, ignored = 0, too_large = 0, binary_skipped = 0, text = 0, binary = 0, errors = 0, total_size = 0; // <-- DODANA KATEGORIA `errors`
    void print() const
    {
        std::cerr << "\n--- STATISTICS ---\n"
                  << "Processed files:     " << processed << "\n"
                  << "  - Text files:      " << text << "\n"
                  << "  - Binary files:    " << binary << "\n"
                  << "Total data size:     " << total_size << " bytes\n"
                  << "Skipped (ignored):   " << ignored << "\n"
                  << "Skipped (too large): " << too_large << "\n"
                  << "Skipped (binary):    " << binary_skipped << "\n"
                  << "Access errors:       " << errors << "\n" // <-- DODANA LINIA W WYDRUKU
                  << "------------------\n";
    }
};

void serialize_directory(const fs::path &input_dir, std::ostream &output_stream, HashAlgorithm algo, bool text_only, uintmax_t size_limit, bool has_limit, bool dry_run, bool verbose, Stats &stats)
{
    auto rules = load_dpignore_rules(input_dir, verbose);
    if (!fs::is_directory(input_dir))
    {
        throw std::runtime_error("Input path is not a directory: " + input_dir.string());
    }
    std::string algo_name = to_string(algo);

    // --- ZMIANA: ZASTƒòPUJEMY PƒòTLƒò `for` PƒòTLƒÑ `while` Z OBS≈ÅUGƒÑ B≈ÅƒòD√ìW ---
    std::error_code ec;
    fs::recursive_directory_iterator it(input_dir, fs::directory_options::skip_permission_denied, ec);
    fs::recursive_directory_iterator end;

    while (it != end)
    {
        // G≈Ç√≥wna logika przetwarzania pliku
        try
        {
            const fs::path &path = it->path();

            if (!it->is_regular_file())
            {
                // Pomijamy katalogi i inne typy, ale robimy to w spos√≥b bezpieczny
                // (w odr√≥≈ºnieniu od `continue`, kt√≥re mog≈Çoby przeskoczyƒá inkrementacjƒô)
            }
            else
            {
                fs::path rel = fs::relative(path, input_dir);
                if (should_ignore(rel, rules, verbose))
                {
                    stats.ignored++;
                }
                else
                {
                    uintmax_t size = fs::file_size(path);
                    if (has_limit && size > size_limit)
                    {
                        if (verbose)
                            std::cerr << "üìè Skipped (too large): " << to_forward_slash(rel) << " (" << size << " bytes)" << std::endl;
                        stats.too_large++;
                    }
                    else
                    {
                        bool is_file_binary = is_binary(path);
                        if (text_only && is_file_binary)
                        {
                            if (verbose)
                                std::cerr << "üóé Skipped (binary, --text-only): " << to_forward_slash(rel) << std::endl;
                            stats.binary_skipped++;
                        }
                        else
                        {
                            if (verbose)
                                std::cerr << "üìÑ Processing: " << to_forward_slash(rel) << std::endl;
                            stats.processed++;
                            stats.total_size += size;
                            std::string hash = compute_hash(path, algo);
                            std::string rel_str = to_forward_slash(rel);

                            if (is_file_binary)
                            {
                                stats.binary++;
                                if (!dry_run)
                                {
                                    output_stream << "--- START BINARY FILE path: \"" << rel_str << "\" size: " << size << " b " << algo_name << ": " << hash << " ---\n";
                                    if (size > 0)
                                    {
                                        std::ifstream file(path, std::ios::binary);
                                        std::vector<uint8_t> data(size);
                                        file.read(reinterpret_cast<char *>(data.data()), size);
                                        output_stream << cppcodec::base64_rfc4648::encode(data);
                                    }
                                    output_stream << END_OF_RECORD;
                                }
                            }
                            else
                            {
                                stats.text++;
                                if (!dry_run)
                                {
                                    output_stream << "--- START TEXT FILE path: \"" << rel_str << "\" size: " << size << " b " << algo_name << ": " << hash << " ---\n";
                                    if (size > 0)
                                    {
                                        std::ifstream file(path, std::ios::binary);
                                        std::vector<char> data(size);
                                        file.read(data.data(), size);
                                        output_stream.write(data.data(), size);
                                    }
                                    output_stream << END_OF_RECORD;
                                }
                            }
                        }
                    }
                }
            }
        }
        catch (const fs::filesystem_error &e)
        {
            stats.errors++;
            std::string error_path_str = to_forward_slash(e.path1());
            std::string error_message = "ERROR: Failed to process path.\nPath: " + error_path_str + "\nReason: " + e.what();
            if (verbose)
                std::cerr << "üî• " << error_message << std::endl;

            if (!dry_run)
            {
                std::string error_hash = compute_hash_from_memory(error_message, algo);
                output_stream << "--- START ERROR MESSAGE path: \"" << error_path_str << "\" size: " << error_message.length() << " b " << algo_name << ": " << error_hash << " ---\n";
                output_stream << error_message;
                output_stream << END_OF_RECORD;
            }
        }

        // Inkrementacja iteratora z obs≈ÇugƒÖ b≈Çƒôd√≥w
        it.increment(ec);
        if (ec)
        {
            stats.errors++;
            std::string error_path_str = to_forward_slash(it->path());
            std::string error_message = "ERROR: Cannot iterate filesystem.\nPath: " + error_path_str + "\nReason: " + ec.message();
            if (verbose)
                std::cerr << "üî• " << error_message << std::endl;

            if (!dry_run)
            {
                std::string error_hash = compute_hash_from_memory(error_message, algo);
                output_stream << "--- START ERROR MESSAGE path: \"" << error_path_str << "\" size: " << error_message.length() << " b " << algo_name << ": " << error_hash << " ---\n";
                output_stream << error_message;
                output_stream << END_OF_RECORD;
            }
            // Spr√≥buj pominƒÖƒá b≈Çƒôdny wpis. Je≈õli to siƒô nie uda, pƒôtla siƒô zako≈Ñczy.
            it.pop(ec);
        }
    }
}

// ... (reszta pliku: Args, parse_args, show_help, main - pozostajƒÖ bez zmian)
struct Args
{
    fs::path input_dir;
    fs::path output_file;
    bool show_help = false;
    bool show_version = false;
    bool text_only = false;
    bool dry_run = false;
    bool show_stats = false;
    bool verbose = false;
    uintmax_t size_limit = 0;
    bool has_limit = false;
    HashAlgorithm algo = HashAlgorithm::BLAKE3;
};
Args parse_args(int argc, char **argv)
{
    Args args;
    std::vector<std::string> pos_args;
    for (int i = 1; i < argc; ++i)
    {
        std::string arg = argv[i];
        if (arg == "-h" || arg == "--help")
        {
            args.show_help = true;
        }
        else if (arg == "-v" || arg == "--version")
        {
            args.show_version = true;
        }
        else if (arg == "-d" || arg == "--dir" || arg == "-i" || arg == "--input")
        {
            if (i + 1 >= argc)
            {
                std::cerr << "Error: Missing argument after " << arg << "\n";
                std::exit(1);
            }
            args.input_dir = argv[++i];
        }
        else if (arg == "-o" || arg == "--out")
        {
            if (i + 1 >= argc)
            {
                std::cerr << "Error: Missing argument after " << arg << "\n";
                std::exit(1);
            }
            args.output_file = argv[++i];
        }
        else if (arg == "-t" || arg == "--text-only")
        {
            args.text_only = true;
        }
        else if (arg == "--dry-run")
        {
            args.dry_run = true;
        }
        else if (arg == "--stats")
        {
            args.show_stats = true;
        }
        else if (arg == "--verbose")
        {
            args.verbose = true;
        }
        else if (arg == "-l" || arg == "--limit")
        {
            if (i + 1 >= argc)
            {
                std::cerr << "Error: Missing argument after " << arg << "\n";
                std::exit(1);
            }
            try
            {
                args.size_limit = parse_size(argv[++i]);
                args.has_limit = true;
            }
            catch (const std::exception &e)
            {
                std::cerr << "Error: Invalid size format: " << argv[i] << " (" << e.what() << ")\n";
                std::exit(1);
            }
        }
        else if (arg == "-a" || arg == "--algorithm")
        {
            if (i + 1 >= argc)
            {
                std::cerr << "Error: Missing argument after " << arg << "\n";
                std::exit(1);
            }
            std::string algo_str = argv[++i];
            std::transform(algo_str.begin(), algo_str.end(), algo_str.begin(), ::tolower);
            if (algo_str == "blake3")
            {
                args.algo = HashAlgorithm::BLAKE3;
            }
            else if (algo_str == "sha256")
            {
                args.algo = HashAlgorithm::SHA256;
            }
            else if (algo_str == "sha3" || algo_str == "sha3-256")
            {
                args.algo = HashAlgorithm::SHA3_256;
            }
            else
            {
                std::cerr << "Error: Unknown algorithm '" << argv[i] << "'. Available: blake3, sha256, sha3-256.\n";
                std::exit(1);
            }
        }
        else
        {
            if (arg[0] == '-')
            {
                std::cerr << "Unknown argument: " << arg << "\nUse -h or --help for usage.\n";
                std::exit(1);
            }
            pos_args.push_back(arg);
        }
    }
    if (!args.show_help && !args.show_version)
    {
        if (args.input_dir.empty() && !pos_args.empty())
        {
            args.input_dir = pos_args[0];
        }
        else if (args.input_dir.empty())
        {
            std::cerr << "Error: Input directory is required.\nUse -h or --help for usage.\n";
            std::exit(1);
        }
    }
    return args;
}
void show_help(const char *exec_name) { std::cout << "DirPacker v" << VERSION << "\n"
                                                  << "Packs a directory structure into a single text-based archive.\n\n"
                                                  << "Usage: " << exec_name << " <input_directory> [OPTIONS]\n"
                                                  << "   or: " << exec_name << " -d <input_directory> [OPTIONS]\n\n"
                                                  << "Arguments:\n"
                                                  << "  <input_directory>   Input directory to pack (required).\n\n"
                                                  << "Options:\n"
                                                  << "  -d, --dir, -i       Alternative way to specify input directory.\n"
                                                  << "  -o, --out FILE      Output file (default: stdout).\n"
                                                  << "  -a, --algorithm ALGO Hash algorithm to use (blake3, sha256, sha3-256). Default: blake3.\n"
                                                  << "  -t, --text-only     Only include text files.\n"
                                                  << "  -l, --limit SIZE    Skip files larger than SIZE (e.g., 100k, 1m, 2g).\n"
                                                  << "  --dry-run           Simulate and show stats, but don't write output.\n"
                                                  << "  --stats             Show statistics on stderr after completion.\n"
                                                  << "  --verbose           Show detailed step-by-step processing logs.\n"
                                                  << "  -v, --version       Show version information.\n"
                                                  << "  -h, --help          Show this help message.\n\n"
                                                  << "Example:\n"
                                                  << "  " << exec_name << " . --algorithm sha3-256 -l 100k --stats -o out.pack\n"
                                                  << std::endl; }
int main(int argc, char **argv)
{
    auto args = parse_args(argc, argv);
    if (args.show_version)
    {
        std::cout << "DirPacker v" << VERSION << std::endl;
        return 0;
    }
    if (args.show_help)
    {
        show_help(argv[0]);
        return 0;
    }
    Stats stats;
    try
    {
        if (args.dry_run)
        {
            serialize_directory(args.input_dir, std::cout, args.algo, args.text_only, args.size_limit, args.has_limit, true, true, stats);
        }
        else if (!args.output_file.empty())
        {
            std::ofstream out(args.output_file, std::ios::binary);
            if (!out)
            {
                throw std::runtime_error("Cannot create output file: " + args.output_file.string());
            }
            serialize_directory(args.input_dir, out, args.algo, args.text_only, args.size_limit, args.has_limit, false, args.verbose, stats);
        }
        else
        {
            serialize_directory(args.input_dir, std::cout, args.algo, args.text_only, args.size_limit, args.has_limit, false, args.verbose, stats);
        }
        if (args.show_stats)
        {
            stats.print();
        }
        if (args.dry_run)
        {
            std::cerr << "Dry run completed. No data was written.\n";
        }
        else if (!args.output_file.empty())
        {
            std::cerr << "Serialization completed successfully. Output saved to: " << args.output_file << std::endl;
        }
    }
    catch (const std::exception &e)
    {
        std::cerr << "A critical error occurred: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
--- END_OF_FILE ---
--- START TEXT FILE path: "meson.build" size: 2955 b blake3: 0066d8997d777160c1adb619249ca71c9a562d11d4d7a62d7891ec767a202c36 ---
# meson.build - WERSJA PRZENO≈öNA (Linux + Windows)

project('dirpacker', 'c', 'cpp',
  version: '1.0.0',
  default_options: ['cpp_std=c++17'])

# --- Zale≈ºno≈õci ---


cppcodec_dep = dependency('cppcodec', fallback: ['cppcodec', 'cppcodec_dep'])
hash_library_dep = dependency('hash_library', fallback: ['hash_library', 'hash_library_dep'])




# --- Biblioteka BLAKE3 ---
blake3_src_dir = 'src/blake3'
c_compiler = meson.get_compiler('c')

# 1. Zbuduj ma≈Çe biblioteki SIMD w C z odpowiednimi flagami
blake3_simd_libs = []
simd_files_c = {
  'sse2': '-msse2',
  'sse41': '-msse4.1',
  'avx2': '-mavx2',
  'avx512': '-mavx512f -mavx512vl -mavx512bw -mavx512dq'
}

foreach name, flag : simd_files_c
  # Meson automatycznie t≈Çumaczy flagi GCC na flagi MSVC (np. -mavx2 na /arch:AVX2)
  if c_compiler.has_argument(flag)
    lib = static_library(
      'blake3-' + name,
      blake3_src_dir + '/blake3_' + name + '.c',
      c_args: flag.split()
    )
    blake3_simd_libs += lib
  endif
endforeach

# 2. Wybierz odpowiednie pliki asemblera w zale≈ºno≈õci od systemu i kompilatora
blake3_asm_sources = []
host_system = host_machine.system()

if host_system == 'windows'
  if c_compiler.get_id() == 'msvc'
    # U≈ºywamy plik√≥w .asm dla kompilatora Microsoftu
    blake3_asm_sources = [
      blake3_src_dir + '/blake3_sse2_x86-64_windows_msvc.asm',
      blake3_src_dir + '/blake3_sse41_x86-64_windows_msvc.asm',
      blake3_src_dir + '/blake3_avx2_x86-64_windows_msvc.asm',
      blake3_src_dir + '/blake3_avx512_x86-64_windows_msvc.asm'
    ]
  else
    # U≈ºywamy plik√≥w .S dla MinGW/GCC na Windows
    blake3_asm_sources = [
      blake3_src_dir + '/blake3_sse2_x86-64_windows_gnu.S',
      blake3_src_dir + '/blake3_sse41_x86-64_windows_gnu.S',
      blake3_src_dir + '/blake3_avx2_x86-64_windows_gnu.S',
      blake3_src_dir + '/blake3_avx512_x86-64_windows_gnu.S'
    ]
  endif
elif host_system == 'linux' or host_system == 'darwin'
  # U≈ºywamy plik√≥w .S dla system√≥w uniksowych
  blake3_asm_sources = [
    blake3_src_dir + '/blake3_sse2_x86-64_unix.S',
    blake3_src_dir + '/blake3_sse41_x86-64_unix.S',
    blake3_src_dir + '/blake3_avx2_x86-64_unix.S',
    blake3_src_dir + '/blake3_avx512_x86-64_unix.S'
  ]
endif

# Lista "zwyk≈Çych" plik√≥w C, wsp√≥lnych dla wszystkich system√≥w
blake3_normal_sources = [
  blake3_src_dir + '/blake3.c',
  blake3_src_dir + '/blake3_dispatch.c',
  blake3_src_dir + '/blake3_portable.c',
]

# 3. Zbuduj g≈Ç√≥wnƒÖ bibliotekƒô BLAKE3
blake3_lib = static_library(
  'blake3',
  blake3_normal_sources + blake3_asm_sources, # ≈ÅƒÖczymy ≈∫r√≥d≈Ça C i ASM
  link_with: blake3_simd_libs
)

# Deklarujemy finalnƒÖ zale≈ºno≈õƒá
blake3_dep = declare_dependency(
  link_with: blake3_lib,
  include_directories: include_directories(blake3_src_dir)
)


# --- Cel g≈Ç√≥wny (plik wykonywalny) ---

executable('dirpacker',
  'src/main.cpp',
  dependencies: [cppcodec_dep, blake3_dep, hash_library_dep],
  install: true
)
--- END_OF_FILE ---
--- START TEXT FILE path: ".dpignore" size: 175 b blake3: 598753ba2cbdce48e7af7098c4e46f2b40623592d7164e23b37a55fbe82e264f ---
build/
.git/
.github/
subprojects/
.vscode/
# src/blake3/blake3_c_rust_bindings/
# src/blake3/cmake/
# src/blake3/dependencies/
# src/blake3/*.S
# src/blake3/*.asm
src/blake3/
--- END_OF_FILE ---
--- START TEXT FILE path: ".gitignore" size: 18 b blake3: 2f0b0f31d9790c55d2d601a97c8ddd91e5ed411e1839df4bebccb4a83610028d ---
/.vscode
/builddir
--- END_OF_FILE ---
--- START TEXT FILE path: "LICENSE" size: 1068 b blake3: d882c608ac09b0f5f6a4eb98adb7c08b3e7a3a71813d10f8e6309175e2e23fac ---
MIT License

Copyright (c) 2025 Marcin Kopa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--- END_OF_FILE ---
