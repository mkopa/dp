--- START TEXT FILE path: "native.ini" size: 146 b blake3: 207e0a027c3b06104c00458c6afdebf3645b5a6f0326ae598acb2f3353c70f80 ---
[host_machine]
system = 'darwin'
cpu_family = 'x86_64'
cpu = 'x86_64'
endian = 'little'

[binaries]
c = '/usr/bin/clang'
cpp = '/usr/bin/clang++'

--- END_OF_FILE ---
--- START TEXT FILE path: "gitpack.sh" size: 1276 b blake3: d7287b22da186fbd67ae37f853c366983caeee6d9ec5bf3e0a988bc12bae5c04 ---
#!/bin/bash

# Usage check
if [ "$#" -ne 1 ]; then
    echo "Error: Invalid number of arguments." >&2
    echo "Usage: $0 <path_to_git_directory>" >&2
    exit 1
fi

source_dir="$1"

# Validate path
if [ ! -d "$source_dir" ]; then
    echo "Error: Source directory '$source_dir' does not exist." >&2
    exit 1
fi

if [ ! -d "$source_dir/.git" ]; then
    echo "Error: Directory '$source_dir' does not appear to be a Git repository (no .git directory)." >&2
    exit 1
fi

# Determine portable base64 command
if base64 --version 2>/dev/null | grep -qi 'gnu'; then
    base64_cmd() { base64 "$1"; }
else
    base64_cmd() { base64 -i "$1"; }  # BSD/macOS variant
fi

# Binary file detection (true if non-text)
is_binary() {
    local file_path="$1"
    LC_ALL=C grep -qI . "$file_path"
    return $((! $?))  # invert result: true = binary
}

# Main loop
git -C "$source_dir" ls-files -c --others --exclude-standard | while IFS= read -r file; do
    full_path="${source_dir}/${file}"

    echo " -> Processing: $file" >&2
    echo "--- START FILE: ${file} ---"

    if is_binary "$full_path"; then
        echo "[base64]"
        base64_cmd "$full_path"
    else
        cat "$full_path"
    fi

    echo
    echo "--- END FILE: ${file} ---"
    echo
done

echo "Finished." >&2


--- END_OF_FILE ---
--- START TEXT FILE path: "README.md" size: 5686 b blake3: cbaaee12076ddeb3661ac82c170496a4d926725c2e4041d6f5bbb2e819e0c9db ---
# dirpacker

> **dirpacker** ‚Äì Lightweight, text-based directory archiver for code sharing and AI prompting.

`dirpacker` is a minimal, dependency-focused tool that serializes an entire directory into a single, human-readable text stream. It's ideal for:
- Sharing project structure with AI assistants (e.g. LLMs)
- Archiving codebases without binary formats
- Debugging or auditing file inclusions/exclusions
- Secure, transparent packaging (no compression, no hidden data)

All files are wrapped in clear markers, and binary files are Base64-encoded. Rules from `.dpignore` (like `.gitignore`) control what's included.

![Example output snippet](https://via.placeholder.com/600x200?text=---+START+TEXT+FILE+main.cpp+---\n#include+<iostream>\n...\n---+END_OF_FILE+---)
*Example of serialized output*



## ‚ú® Features

- ‚úÖ **Text-only output** ‚Äì safe for AI, logs, diffs
- ‚úÖ **Binary file support** via Base64 encoding
- ‚úÖ **`.dpignore` support** ‚Äì ignore files/dirs like `.gitignore`
- ‚úÖ **Filter by type**: `--text-only` skips binaries
- ‚úÖ **Limit by size**: `-l 100k` skips large files
- ‚úÖ **Dry-run & stats**: preview what would be packed
- ‚úÖ **No compression** ‚Äì fully inspectable output
- ‚úÖ **Cross-platform**: Linux, macOS, Windows (MSVC/MinGW)



## üõ†Ô∏è Build Instructions

`dirpacker` uses **Meson + Ninja** ‚Äì fast, modern, and portable.

### Prerequisites

- **C++17 compiler** (GCC 8+, Clang 7+, MSVC 19.14+)
- **Meson** (v0.55+)
- **Ninja** (bundled with Meson on most systems)
- **Git** (to clone)

Install Meson:
```bash
# Linux/macOS (pip)
pip3 install meson ninja

# Ubuntu/Debian
sudo apt install meson ninja-build

# Fedora
sudo dnf install meson ninja-build

# macOS (Homebrew)
brew install meson ninja

# Windows (MSYS2)
pacman -S meson mingw-w64-x86_64-ninja
```



### üêß Linux & üçè macOS

```bash
# Clone the repo
git clone https://github.com/mkopa/dp.git
cd dp

# Configure build
meson setup build

# Compile
meson compile -C build

# Run
./build/dirpacker --help
```



### üíª Windows

#### Option 1: MSYS2 / MinGW-w64 (Recommended)

```bash
# Install MSYS2 from https://www.msys2.org/
# Open "MSYS2 MinGW 64-bit"

# Update and install
pacman -Syu
pacman -S git mingw-w64-x86_64-gcc mingw-w64-x86_64-meson mingw-w64-x86_64-ninja

# Clone and build
git clone https://github.com/mkopa/dp.git
cd dp
meson setup build
meson compile -C build

# Run
./build/dirpacker.exe --help
```

#### Option 2: Visual Studio (MSVC)

Ensure you have **Visual Studio 2019+** with C++ tools.

```bash
# Open x64 Native Tools Command Prompt
git clone https://github.com/mkopa/dp.git
cd dp

# Meson will auto-detect MSVC
meson setup build
meson compile -C build

dirpacker.exe --help
```



## üß∞ Usage

```bash
dirpacker -d <DIRECTORY> [OPTIONS]
```

### Required
- `-d, --dir DIR` ‚Äì input directory to pack

### Optional
- `-o, --out FILE` ‚Äì output file (default: stdout)
- `-t, --text-only` ‚Äì skip binary files
- `-l, --limit SIZE` ‚Äì skip files larger than SIZE (e.g. `100k`, `1m`, `512b`)
- `--dry-run` ‚Äì simulate without writing
- `--stats` ‚Äì show summary after completion
- `-v, --version` ‚Äì show version
- `-h, --help` ‚Äì show help



### Examples

```bash
# Pack current dir to stdout
dirpacker -d .

# Save to file
dirpacker -d . -o project.pack

# Pipe to another tool
dirpacker -d src -l 100k | wc -c

# Dry run with stats
dirpacker -d . --dry-run --stats

# Only text files, max 50KB
dirpacker -d . -t -l 50k -o code_text.pack
```



## üìÅ `.dpignore`

Place a `.dpignore` file in your input directory to exclude files. Syntax is `.gitignore`-like:

```gitignore
# Comments
*.log
*.tmp
build/
dist/
node_modules/
*.exe
*.dll

# Exceptions
!important.txt
!docs/README.md
```

Rules are matched recursively. Paths are normalized to forward slashes (`/`).

> üí° Tip: Use `--dry-run --stats` to verify what will be included.



## üì¶ Output Format

Each file is wrapped like this:

```
--- START TEXT FILE path/to/file.txt 1234 ---
(file content here)
--- END_OF_FILE ---
```

or for binaries:

```
--- START BINARY FILE image.png 5678 ---
(base64-encoded data)
--- END_OF_FILE ---
```

This makes parsing and debugging trivial.



## üìÑ License

MIT License ‚Äì see [LICENSE](LICENSE) for details.

> Copyright ¬© 2025 Marcin

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files, to deal in the software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the software, and to permit persons to whom the software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



## üôå Contributing

PRs welcome! Please ensure:
- Code compiles on all platforms
- No new dependencies
- Follows existing style
- Updates README if needed



## üêû Bug Reports

Open an issue with:
- OS and compiler
- `meson --version`
- Exact command
- Expected vs actual output



> üè∑Ô∏è `dirpacker` ‚Äì because sometimes you just need to send the code, not the noise.
--- END_OF_FILE ---
--- START TEXT FILE path: "src/dirpacker.cpp" size: 11528 b blake3: 339c62e9d39bb833be5af35890178174a3232838727d7eac878c7486bfa3c2e5 ---
#include "dirpacker/dirpacker.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <stdexcept>
#include <algorithm>
#include <sstream>
#include <regex>
#include <iomanip>
#include <map>
#include <system_error>

#include "blake3.h"
#include <cppcodec/base64_rfc4648.hpp>
#include "sha256.h"
#include "sha3.h"

namespace dp {

namespace {

const std::string END_OF_RECORD = "\n--- END_OF_FILE ---\n";

std::string to_string(HashAlgorithm algo) {
    static const std::map<HashAlgorithm, std::string> lookup = {
        {HashAlgorithm::BLAKE3, "blake3"},
        {HashAlgorithm::SHA256, "sha256"},
        {HashAlgorithm::SHA3_256, "sha3-256"}};
    return lookup.at(algo);
}

std::string bytes_to_hex(const uint8_t *bytes, size_t len) {
    std::stringstream ss;
    ss << std::hex << std::setfill('0');
    for (size_t i = 0; i < len; ++i) {
        ss << std::setw(2) << static_cast<int>(bytes[i]);
    }
    return ss.str();
}

std::string compute_hash_from_memory(const std::string &data, HashAlgorithm algo) {
    const char *data_ptr = data.c_str();
    size_t data_len = data.length();
    switch (algo) {
    case HashAlgorithm::BLAKE3: {
        uint8_t hash[BLAKE3_OUT_LEN];
        blake3_hasher hasher;
        blake3_hasher_init(&hasher);
        blake3_hasher_update(&hasher, data_ptr, data_len);
        blake3_hasher_finalize(&hasher, hash, BLAKE3_OUT_LEN);
        return bytes_to_hex(hash, BLAKE3_OUT_LEN);
    }
    case HashAlgorithm::SHA256: {
        SHA256 sha256;
        sha256.add(data_ptr, data_len);
        return sha256.getHash();
    }
    case HashAlgorithm::SHA3_256: {
        SHA3 sha3(SHA3::Bits256);
        sha3.add(data_ptr, data_len);
        return sha3.getHash();
    }
    }
    throw std::runtime_error("Unknown hash algorithm.");
}

std::string compute_hash(const fs::path &path, HashAlgorithm algo) {
    std::ifstream file(path, std::ios::binary);
    if (!file) throw std::runtime_error("Cannot open file for hashing: " + path.string());
    std::vector<char> buffer(8192);
    switch (algo) {
    case HashAlgorithm::BLAKE3: {
        blake3_hasher hasher;
        blake3_hasher_init(&hasher);
        while (file.read(buffer.data(), buffer.size()) || file.gcount() > 0) {
            blake3_hasher_update(&hasher, reinterpret_cast<const uint8_t *>(buffer.data()), file.gcount());
        }
        uint8_t hash[BLAKE3_OUT_LEN];
        blake3_hasher_finalize(&hasher, hash, BLAKE3_OUT_LEN);
        return bytes_to_hex(hash, BLAKE3_OUT_LEN);
    }
    case HashAlgorithm::SHA256: {
        SHA256 sha256;
        while (file.read(buffer.data(), buffer.size()) || file.gcount() > 0) {
            sha256.add(buffer.data(), file.gcount());
        }
        return sha256.getHash();
    }
    case HashAlgorithm::SHA3_256: {
        SHA3 sha3(SHA3::Bits256);
        while (file.read(buffer.data(), buffer.size()) || file.gcount() > 0) {
            sha3.add(buffer.data(), file.gcount());
        }
        return sha3.getHash();
    }
    }
    throw std::runtime_error("Unknown hash algorithm.");
}

std::string to_forward_slash(const fs::path &p) { return p.generic_string(); }

bool is_binary(const fs::path &file_path) {
    constexpr size_t check_size = 8000;
    std::ifstream file(file_path, std::ios::binary);
    if (!file) throw std::runtime_error("Cannot open file for binary check: " + file_path.string());
    std::vector<char> buffer(check_size);
    file.read(buffer.data(), buffer.size());
    std::streamsize bytes_read = file.gcount();
    return std::find(buffer.begin(), buffer.begin() + bytes_read, '\0') != buffer.begin() + bytes_read;
}

struct IgnoreRule {
    std::regex regex;
    bool is_negated;
};

std::vector<IgnoreRule> load_dpignore_rules(const fs::path &base_dir, bool verbose) {
    std::vector<IgnoreRule> rules;
    fs::path ignore_file = base_dir / ".dpignore";
    if (verbose) std::cerr << "üîç Looking for .dpignore in: " << base_dir << std::endl;
    if (fs::exists(ignore_file) && fs::is_regular_file(ignore_file)) {
        if (verbose) std::cerr << "‚úÖ .dpignore found and opened." << std::endl;
        std::ifstream file(ignore_file);
        if (!file.is_open()) {
            std::cerr << "Warning: Could not read .dpignore in " << base_dir << std::endl;
            return rules;
        }
        std::string line;
        while (std::getline(file, line)) {
            line.erase(0, line.find_first_not_of(" \t\r\n"));
            line.erase(line.find_last_not_of(" \t\r\n") + 1);
            if (line.empty() || line[0] == '#') continue;
            bool is_negated = (line[0] == '!');
            if (is_negated) line = line.substr(1);
            if (line.empty()) continue;
            
            std::string regex_pattern;
            for (char c : line) {
                if (c == '*') regex_pattern += ".*";
                else if (c == '?') regex_pattern += ".";
                else if (std::string(".+()[]{}|^$\\").find(c) != std::string::npos) regex_pattern += std::string("\\") + c;
                else regex_pattern += c;
            }
            try {
                rules.push_back({std::regex(regex_pattern, std::regex_constants::icase), is_negated});
                if (verbose) std::cerr << "üìã Loaded rule: " << (is_negated ? "EXCEPT " : "IGNORE ") << regex_pattern << std::endl;
            } catch (const std::regex_error &e) {
                std::cerr << "Warning: Invalid regex in .dpignore: " << line << " (" << e.what() << ")" << std::endl;
            }
        }
    } else if (verbose) {
        std::cerr << "‚ùå .dpignore NOT found in: " << base_dir << std::endl;
    }
    return rules;
}

bool should_ignore(const fs::path &path, const std::vector<IgnoreRule> &rules, bool verbose) {
    std::string path_str = to_forward_slash(path);
    bool is_ignored = false;
    for (const auto &rule : rules) {
        if (std::regex_search(path_str, rule.regex)) {
            is_ignored = !rule.is_negated;
        }
    }
    if (is_ignored && verbose) {
        std::cerr << "üö´ Ignored by rule: " << path_str << std::endl;
    }
    return is_ignored;
}


void serialize_directory(const PackerConfig& config, Stats& stats) {
    auto rules = load_dpignore_rules(config.input_dir, config.verbose);
    if (!fs::is_directory(config.input_dir)) {
        throw std::runtime_error("Input path is not a directory: " + config.input_dir.string());
    }
    std::string algo_name = to_string(config.algo);
    
    std::error_code ec;
    fs::recursive_directory_iterator it(config.input_dir, fs::directory_options::skip_permission_denied, ec);
    fs::recursive_directory_iterator end;

    while (it != end) {
        try {
            const fs::path &path = it->path();
            if (it->is_regular_file()) {
                fs::path rel = fs::relative(path, config.input_dir);
                if (should_ignore(rel, rules, config.verbose)) {
                    stats.ignored++;
                } else {
                    uintmax_t size = fs::file_size(path);
                    if (config.has_limit && size > config.size_limit) {
                        if (config.verbose) std::cerr << "üìè Skipped (too large): " << to_forward_slash(rel) << " (" << size << " bytes)" << std::endl;
                        stats.too_large++;
                    } else {
                        bool is_file_binary = is_binary(path);
                        if (config.text_only && is_file_binary) {
                            if (config.verbose) std::cerr << "üóé Skipped (binary, --text-only): " << to_forward_slash(rel) << std::endl;
                            stats.binary_skipped++;
                        } else {
                            if (config.verbose) std::cerr << "üìÑ Processing: " << to_forward_slash(rel) << std::endl;
                            stats.processed++;
                            stats.total_size += size;
                            std::string hash = compute_hash(path, config.algo);
                            std::string rel_str = to_forward_slash(rel);

                            if (is_file_binary) {
                                stats.binary++;
                                if (!config.dry_run) {
                                    config.output_stream << "--- START BINARY FILE path: \"" << rel_str << "\" size: " << size << " b " << algo_name << ": " << hash << " ---\n";
                                    if (size > 0) {
                                        std::ifstream file(path, std::ios::binary);
                                        std::vector<uint8_t> data(size);
                                        file.read(reinterpret_cast<char *>(data.data()), size);
                                        config.output_stream << cppcodec::base64_rfc4648::encode(data);
                                    }
                                    config.output_stream << END_OF_RECORD;
                                }
                            } else {
                                stats.text++;
                                if (!config.dry_run) {
                                    config.output_stream << "--- START TEXT FILE path: \"" << rel_str << "\" size: " << size << " b " << algo_name << ": " << hash << " ---\n";
                                    if (size > 0) {
                                        std::ifstream file(path, std::ios::binary);
                                        config.output_stream << file.rdbuf();
                                    }
                                    config.output_stream << END_OF_RECORD;
                                }
                            }
                        }
                    }
                }
            }
        } catch (const fs::filesystem_error &e) {
            stats.errors++;
            std::string error_path_str = to_forward_slash(e.path1());
            std::string error_message = "ERROR: Failed to process path.\nPath: " + error_path_str + "\nReason: " + e.what();
            if (config.verbose) std::cerr << "üî• " << error_message << std::endl;
            if (!config.dry_run) {
                std::string error_hash = compute_hash_from_memory(error_message, config.algo);
                config.output_stream << "--- START ERROR MESSAGE path: \"" << error_path_str << "\" size: " << error_message.length() << " b " << algo_name << ": " << error_hash << " ---\n";
                config.output_stream << error_message;
                config.output_stream << END_OF_RECORD;
            }
        }
        
        it.increment(ec);
        if (ec) {
            stats.errors++;
            std::string error_path_str = to_forward_slash(it->path());
            std::string error_message = "ERROR: Cannot iterate filesystem.\nPath: " + error_path_str + "\nReason: " + ec.message();
            if (config.verbose) std::cerr << "üî• " << error_message << std::endl;
            if (!config.dry_run) {
                 std::string error_hash = compute_hash_from_memory(error_message, config.algo);
                config.output_stream << "--- START ERROR MESSAGE path: \"" << error_path_str << "\" size: " << error_message.length() << " b " << algo_name << ": " << error_hash << " ---\n";
                config.output_stream << error_message;
                config.output_stream << END_OF_RECORD;
            }
            it.pop(ec);
        }
    }
}

} 

Stats pack(const PackerConfig& config) {
    Stats stats;
    serialize_directory(config, stats);
    return stats;
}

}
--- END_OF_FILE ---
--- START TEXT FILE path: "app/main.cpp" size: 7672 b blake3: fc240c0804ffe2a56f0202e9b6cbd90ae8ab396a06dd3a2b1e157cf8232e4a31 ---
#include "dirpacker/dirpacker.h"

#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <filesystem>
#include <stdexcept>
#include <algorithm>
#include <regex>

namespace fs = std::filesystem;

namespace {
// ... ca≈Ça zawarto≈õƒá `namespace {}` pozostaje bez zmian (Args, parse_args, etc.) ...
constexpr const char *VERSION = "1.3.1";

struct Args {
    fs::path input_dir;
    fs::path output_file;
    bool show_help = false;
    bool show_version = false;
    bool show_stats = false;
    bool text_only = false;
    bool dry_run = false;
    bool verbose = false;
    uintmax_t size_limit = 0;
    bool has_limit = false;
    dp::HashAlgorithm algo = dp::HashAlgorithm::BLAKE3;
};

uintmax_t parse_size(const std::string &size_str) {
    std::regex re(R"((\d+)([bkmg]?)?)", std::regex_constants::icase);
    std::smatch match;
    if (std::regex_match(size_str, match, re)) {
        uintmax_t value = std::stoull(match[1].str());
        if (match[2].matched) {
            char unit = std::tolower(match[2].str()[0]);
            if (unit == 'k') value *= 1024;
            else if (unit == 'm') value *= 1024 * 1024;
            else if (unit == 'g') value *= 1024 * 1024 * 1024;
        }
        return value;
    }
    throw std::invalid_argument("Invalid size format: " + size_str);
}

Args parse_args(int argc, char **argv) {
    Args args;
    std::vector<std::string> pos_args;

    for (int i = 1; i < argc; ++i) {
        std::string arg = argv[i];
        if (arg == "-h" || arg == "--help") args.show_help = true;
        else if (arg == "-v" || arg == "--version") args.show_version = true;
        else if (arg == "-d" || arg == "--dir") {
            if (i + 1 < argc) args.input_dir = argv[++i];
            else { std::cerr << "Error: Missing argument for " << arg << std::endl; exit(1); }
        } else if (arg == "-o" || arg == "--out") {
            if (i + 1 < argc) args.output_file = argv[++i];
            else { std::cerr << "Error: Missing argument for " << arg << std::endl; exit(1); }
        } else if (arg == "-t" || arg == "--text-only") args.text_only = true;
        else if (arg == "--dry-run") args.dry_run = true;
        else if (arg == "--stats") args.show_stats = true;
        else if (arg == "--verbose") args.verbose = true;
        else if (arg == "-l" || arg == "--limit") {
            if (i + 1 < argc) {
                try {
                    args.size_limit = parse_size(argv[++i]);
                    args.has_limit = true;
                } catch (const std::exception& e) {
                    std::cerr << "Error: " << e.what() << std::endl; exit(1);
                }
            } else { std::cerr << "Error: Missing argument for " << arg << std::endl; exit(1); }
        } else if (arg == "-a" || arg == "--algorithm") {
            if (i + 1 < argc) {
                std::string algo_str = argv[++i];
                std::transform(algo_str.begin(), algo_str.end(), algo_str.begin(), ::tolower);
                if (algo_str == "blake3") args.algo = dp::HashAlgorithm::BLAKE3;
                else if (algo_str == "sha256") args.algo = dp::HashAlgorithm::SHA256;
                else if (algo_str == "sha3" || algo_str == "sha3-256") args.algo = dp::HashAlgorithm::SHA3_256;
                else { std::cerr << "Error: Unknown algorithm '" << algo_str << "'" << std::endl; exit(1); }
            } else { std::cerr << "Error: Missing argument for " << arg << std::endl; exit(1); }
        } else if (arg[0] == '-') {
            std::cerr << "Unknown argument: " << arg << std::endl; exit(1);
        } else {
            pos_args.push_back(arg);
        }
    }

    if (!args.show_help && !args.show_version) {
        if (args.input_dir.empty()) {
            if (!pos_args.empty()) args.input_dir = pos_args[0];
            else { std::cerr << "Error: Input directory is required." << std::endl; exit(1); }
        }
    }
    return args;
}

void show_help(const char *exec_name) {
    std::cout << "DirPacker v" << VERSION << " (Application Layer)\n"
              << "Packs a directory structure using the DirPacker library.\n\n"
              << "Usage: " << exec_name << " <input_directory> [OPTIONS]\n"
              << "   or: " << exec_name << " -d <input_directory> [OPTIONS]\n\n"
              << "Arguments:\n"
              << "  <input_directory>   Input directory to pack (required).\n\n"
              << "Options:\n"
              << "  -d, --dir, -i       Alternative way to specify input directory.\n"
              << "  -o, --out FILE      Output file (default: stdout).\n"
              << "  -a, --algorithm ALGO Hash algorithm to use (blake3, sha256, sha3-256). Default: blake3.\n"
              << "  -t, --text-only     Only include text files.\n"
              << "  -l, --limit SIZE    Skip files larger than SIZE (e.g., 100k, 1m, 2g).\n"
              << "  --dry-run           Simulate and show stats, but don't write output.\n"
              << "  --stats             Show statistics on stderr after completion.\n"
              << "  --verbose           Show detailed step-by-step processing logs.\n"
              << "  -v, --version       Show version information.\n"
              << "  -h, --help          Show this help message.\n\n"
              << "Example:\n"
              << "  " << exec_name << " . --algorithm sha3-256 -l 100k --stats -o out.pack\n"
              << std::endl;
}

void print_stats(const dp::Stats& stats) {
    std::cerr << "\n--- STATISTICS ---\n"
              << "Processed files:     " << stats.processed << "\n"
              << "  - Text files:      " << stats.text << "\n"
              << "  - Binary files:    " << stats.binary << "\n"
              << "Total data size:     " << stats.total_size << " bytes\n"
              << "Skipped (ignored):   " << stats.ignored << "\n"
              << "Skipped (too large): " << stats.too_large << "\n"
              << "Skipped (binary):    " << stats.binary_skipped << "\n"
              << "Access errors:       " << stats.errors << "\n"
              << "------------------\n";
}
}

int main(int argc, char **argv) {
    const auto args = parse_args(argc, argv);

    if (args.show_version) {
        std::cout << "DirPacker v" << VERSION << std::endl;
        return 0;
    }
    if (args.show_help) {
        show_help(argv[0]);
        return 0;
    }

    try {
        if (!args.output_file.empty()) {
            std::ofstream out(args.output_file, std::ios::binary);
            if (!out) {
                throw std::runtime_error("Cannot create output file: " + args.output_file.string());
            }
            dp::PackerConfig config = {args.input_dir, out, args.algo, args.text_only, args.size_limit, args.has_limit, args.dry_run, args.verbose};
            dp::Stats final_stats = dp::pack(config);
            if (args.show_stats) {
                print_stats(final_stats);
            }
        } else {
            dp::PackerConfig config = {args.input_dir, std::cout, args.algo, args.text_only, args.size_limit, args.has_limit, args.dry_run, args.verbose};
            dp::Stats final_stats = dp::pack(config);
            if (args.show_stats) {
                print_stats(final_stats);
            }
        }

        if (args.dry_run) {
            std::cerr << "Dry run completed. No data was written.\n";
        } else if (!args.output_file.empty()) {
            std::cerr << "Serialization completed. Output saved to: " << args.output_file << std::endl;
        }

    } catch (const std::exception &e) {
        std::cerr << "A critical error occurred: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
--- END_OF_FILE ---
--- START TEXT FILE path: "include/dirpacker/dirpacker.h" size: 731 b blake3: 6c6514ae9d401e40eda3670a77cd498224dc450540a8e42dfa6b76488a9f4ccc ---
#pragma once

#include <string>
#include <filesystem>
#include <ostream>
#include <cstdint>
#include <vector>

namespace dp {

namespace fs = std::filesystem;

enum class HashAlgorithm {
    BLAKE3,
    SHA256,
    SHA3_256
};

struct Stats {
    uintmax_t processed = 0, ignored = 0, too_large = 0, 
              binary_skipped = 0, text = 0, binary = 0, 
              errors = 0, total_size = 0;
};

struct PackerConfig {
    fs::path input_dir;
    std::ostream& output_stream;
    HashAlgorithm algo = HashAlgorithm::BLAKE3;
    bool text_only = false;
    uintmax_t size_limit = 0;
    bool has_limit = false;
    bool dry_run = false;
    bool verbose = false;
};

Stats pack(const PackerConfig& config);

} // namespace dp
--- END_OF_FILE ---
--- START TEXT FILE path: "meson.build" size: 1173 b blake3: 098a173b5d245e07ffbe23263e5fd6a517356a96b923314a7f338b770d5aebd5 ---
# meson.build - WERSJA MODU≈ÅOWA (biblioteka + aplikacja)

project('dirpacker', 'c', 'cpp',
  version: '1.3.0',
  default_options: [
    'cpp_std=c++17',
    'default_library=static'
  ])

# --- Zale≈ºno≈õci zewnƒôtrzne (w subprojektach) ---
cppcodec_dep = dependency('cppcodec', fallback: ['cppcodec', 'cppcodec_dep'])
blake3_dep = dependency('blake3', fallback: ['blake3', 'blake3_dep'])
hash_library_dep = dependency('hash_library', fallback: ['hash_library', 'hash_library_dep'])

# --- Definicja naszej biblioteki DirPacker ---

# Deklarujemy, gdzie sƒÖ publiczne nag≈Ç√≥wki naszej biblioteki
dirpacker_inc = include_directories('include')

# Budujemy bibliotekƒô (statycznƒÖ lub dynamicznƒÖ)
dirpacker_lib = library('dirpacker',
  'src/dirpacker.cpp',
  include_directories: dirpacker_inc,
  dependencies: [cppcodec_dep, blake3_dep, hash_library_dep],
  install: true,
)

# Tworzymy obiekt "zale≈ºno≈õci" dla naszej biblioteki
dirpacker_dep = declare_dependency(
  link_with: dirpacker_lib,
  include_directories: dirpacker_inc
)


# --- Cel g≈Ç√≥wny (plik wykonywalny) ---

executable('dirpacker',
  'app/main.cpp',
  dependencies: [dirpacker_dep],
  install: true
)
--- END_OF_FILE ---
--- START TEXT FILE path: ".dpignore" size: 175 b blake3: 598753ba2cbdce48e7af7098c4e46f2b40623592d7164e23b37a55fbe82e264f ---
build/
.git/
.github/
subprojects/
.vscode/
# src/blake3/blake3_c_rust_bindings/
# src/blake3/cmake/
# src/blake3/dependencies/
# src/blake3/*.S
# src/blake3/*.asm
src/blake3/
--- END_OF_FILE ---
--- START TEXT FILE path: ".gitignore" size: 18 b blake3: 2f0b0f31d9790c55d2d601a97c8ddd91e5ed411e1839df4bebccb4a83610028d ---
/.vscode
/builddir
--- END_OF_FILE ---
--- START TEXT FILE path: "LICENSE" size: 1068 b blake3: d882c608ac09b0f5f6a4eb98adb7c08b3e7a3a71813d10f8e6309175e2e23fac ---
MIT License

Copyright (c) 2025 Marcin Kopa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

--- END_OF_FILE ---
